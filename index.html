<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Space Block Invaders</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet">
<style>
  body {
    background:#000;margin:0;height:100vh;
    display:flex;align-items:center;justify-content:center;
    font-family:'Orbitron',sans-serif;
  }
  canvas {
    background:#000;border:2px solid #444;
    display:block;margin:auto;
    touch-action:none;
    width:100%;max-width:480px;height:auto;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="480" height="480"></canvas>
<script>
const canvas=document.getElementById("gameCanvas");
const ctx=canvas.getContext("2d");

/* ===== Audio ===== */
let audioCtx=null; let bgmTimer=null;
function initAudio(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }
function playBeep(freq,dur=0.15){
  if(!audioCtx) return;
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type="square"; o.frequency.value=freq;
  o.connect(g); g.connect(audioCtx.destination);
  g.gain.setValueAtTime(0.2,audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+dur);
  o.start(); o.stop(audioCtx.currentTime+dur);
}
function playNoise(dur=0.4){
  if(!audioCtx) return;
  const buffer=audioCtx.createBuffer(1,audioCtx.sampleRate*dur,audioCtx.sampleRate);
  const data=buffer.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
  const src=audioCtx.createBufferSource(); src.buffer=buffer;
  const g=audioCtx.createGain(); src.connect(g); g.connect(audioCtx.destination);
  g.gain.setValueAtTime(0.3,audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+dur);
  src.start();
}
function startBGM(){
  if(!audioCtx) return;
  stopBGM();
  const notes=[261.6,329.6,392.0,493.9]; // C E G B
  let i=0;
  bgmTimer=setInterval(()=>{
    playBeep(notes[i%notes.length],0.25);
    i++;
  },400);
}
function stopBGM(){ if(bgmTimer){clearInterval(bgmTimer);bgmTimer=null;} }

/* ===== Game State ===== */
let gameState="intro"; // ←最初はイントロ
let score=0,level=1,maxLevel=7;
let rightPressed=false,leftPressed=false;
const paddleWidth=70,paddleHeight=10; let paddleX=205;
let balls=[{x:240,y:450,dx:2,dy:-2}]; let ballRadius=8; let bricksBroken=0;
let invaders=[], bricks=[]; let enemyBullets=[]; let invaderDX=1;

/* ===== Bricks & Invaders ===== */
const invaderRowCount=3,invaderColCount=7,invaderWidth=30,invaderHeight=20,invaderPadding=10;
const brickRowCount=3,brickColCount=7,brickWidth=30,brickHeight=10,brickPadding=10;
const brickOffsetTop=60;
const totalBrickWidth=brickColCount*brickWidth+(brickColCount-1)*brickPadding;
const brickOffsetLeft=(canvas.width-totalBrickWidth)/2;
const totalInvaderWidth=invaderColCount*invaderWidth+(invaderColCount-1)*invaderPadding;
const invaderOffsetLeft=(canvas.width-totalInvaderWidth)/2;
const brickColors=["#3399FF","#33FF66","#AA66FF","#FF4444","#FFAA33","#33FFFF","#FFD700"];

function initInvaders(){
  invaders=[];
  const baseY=brickOffsetTop+brickRowCount*(brickHeight+brickPadding)+20;
  for(let c=0;c<invaderColCount;c++){
    invaders[c]=[];
    for(let r=0;r<invaderRowCount;r++){
      invaders[c][r]={
        x:invaderOffsetLeft+c*(invaderWidth+invaderPadding),
        y:baseY+r*(invaderHeight+invaderPadding),
        alive:true
      };
    }
  }
}
function initBricks(){
  bricks=[];
  for(let c=0;c<brickColCount;c++){
    bricks[c]=[];
    for(let r=0;r<brickRowCount;r++){
      let x=brickOffsetLeft+c*(brickWidth+brickPadding);
      let y=brickOffsetTop+r*(brickHeight+brickPadding);
      bricks[c][r]={x,y,alive:true};
    }
  }
}
function retryGame(){
  score=0;level=1;bricksBroken=0;
  balls=[{x:240,y:450,dx:2,dy:-2}];
  enemyBullets=[]; invaderDX=1;
  gameState="intro"; stopBGM();
}

/* ===== Background ===== */
const starLayers=[{count:70,speed:0.15,stars:[],twinkle:true},{count:50,speed:0.30,stars:[],twinkle:true},{count:30,speed:0.55,stars:[],twinkle:false}];
function initStars(){for(const L of starLayers){L.stars=Array.from({length:L.count},()=>({x:Math.random()*canvas.width,y:Math.random()*canvas.height,r:Math.random()*1.8+0.4,a:Math.random()*0.6+0.4,p:Math.random()*6.28}));}} 
initStars();
let t=0; let planets=[{emo:"🌏",r:80,cx:370,cy:130,ang:0,angV:0.003,size:36}];
function drawStars(){
  for(const L of starLayers){
    for(const s of L.stars){
      const tw=L.twinkle?(0.35+0.65*Math.abs(Math.sin(t*0.02+s.p))):1;
      ctx.globalAlpha=s.a*tw;
      ctx.beginPath();ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
      ctx.fillStyle="#FFF";ctx.fill();
      ctx.globalAlpha=1;
      s.y+=L.speed;if(s.y>canvas.height){s.y=0;s.x=Math.random()*canvas.width;}
    }
  }
}
function drawPlanets(){
  for(const p of planets){
    p.ang+=p.angV;
    let x=p.cx+Math.cos(p.ang)*p.r;
    let y=p.cy+Math.sin(p.ang)*p.r*0.6;
    ctx.font=`${p.size}px Orbitron`; ctx.fillText(p.emo,x,y);
  }
}

/* ===== Buttons ===== */
let buttons=[];
function drawButton(label,x,y,w,h,color="#0ff"){
  ctx.strokeStyle=color; ctx.lineWidth=2; ctx.strokeRect(x,y,w,h);
  ctx.font="20px Orbitron"; ctx.fillStyle=color; ctx.textAlign="center";
  ctx.fillText(label,x+w/2,y+h/2+6);
  buttons.push({label,x,y,w,h});
}
canvas.addEventListener("click",e=>{
  const rect=canvas.getBoundingClientRect();
  const scaleX=canvas.width/rect.width;
  const scaleY=canvas.height/rect.height;
  const mx=(e.clientX-rect.left)*scaleX,my=(e.clientY-rect.top)*scaleY;
  for(const b of buttons){
    if(mx>=b.x&&mx<=b.x+b.w&&my>=b.y&&my<=b.y+b.h){
      if(b.label==="START"){initAudio();startBGM();initInvaders();initBricks();gameState="playing";}
      if(b.label==="RESTART"){retryGame();initAudio();startBGM();}
    }
  }
});

/* ===== Draw ===== */
function drawPaddle(){ctx.fillStyle="#0CF";ctx.fillRect(paddleX,canvas.height-paddleHeight,paddleWidth,paddleHeight);}
function drawBalls(){ctx.fillStyle="red";for(const b of balls){ctx.beginPath();ctx.arc(b.x,b.y,ballRadius,0,Math.PI*2);ctx.fill();}}
function drawInvaders(){ctx.font="24px Orbitron";for(let c=0;c<invaderColCount;c++){for(let r=0;r<invaderRowCount;r++){let inv=invaders[c][r];if(inv.alive)ctx.fillText("👾",inv.x,inv.y+20);}}}
function drawBricks(){for(let c=0;c<brickColCount;c++){for(let r=0;r<brickRowCount;r++){let b=bricks[c][r];if(b.alive){ctx.fillStyle=brickColors[level-1]||"#888";ctx.fillRect(b.x,b.y,brickWidth,brickHeight);}}}}
function drawEnemyBullets(){ctx.fillStyle="yellow";for(const b of enemyBullets){ctx.fillRect(b.x,b.y,4,10);}}

/* ===== Collision ===== */
function collisionBricks(){
  for(let c=0;c<brickColCount;c++){
    for(let r=0;r<brickRowCount;r++){
      let br=bricks[c][r];
      if(br.alive){
        for(let b of balls){
          if(b.x>br.x&&b.x<br.x+brickWidth&&b.y>br.y&&b.y<br.y+brickHeight){
            br.alive=false;b.dy=-b.dy;score+=50;bricksBroken++;
            playBeep(880);
            if(bricksBroken%5===0){
              balls.push({x:240,y:450,dx:(Math.random()>0.5?2:-2),dy:-2});
            }
          }
        }
      }
    }
  }
}
function collisionInvaders(){
  for(let c=0;c<invaderColCount;c++){
    for(let r=0;r<invaderRowCount;r++){
      let inv=invaders[c][r];
      if(inv.alive){
        for(let b of balls){
          if(b.x>inv.x&&b.x<inv.x+invaderWidth&&b.y>inv.y&&b.y<inv.y+invaderHeight){
            inv.alive=false;b.dy=-b.dy;score+=100;
            playBeep(440);
          }
        }
      }
    }
  }
}

/* ===== Invaders move & attack ===== */
function moveInvaders(){
  let edgeHit=false;
  for(let c=0;c<invaderColCount;c++){
    for(let r=0;r<invaderRowCount;r++){
      let inv=invaders[c][r];
      if(inv.alive){
        inv.x+=invaderDX;
        if(inv.x<=0||inv.x+invaderWidth>=canvas.width) edgeHit=true;
      }
    }
  }
  if(edgeHit){
    invaderDX=-invaderDX;
    for(let c=0;c<invaderColCount;c++){
      for(let r=0;r<invaderRowCount;r++){
        if(invaders[c][r].alive) invaders[c][r].y+=invaderHeight/2;
      }
    }
  }
}
function invaderShoot(){
  if(Math.random()<0.02){
    let aliveInv=[];
    for(let c=0;c<invaderColCount;c++){
      for(let r=0;r<invaderRowCount;r++){
        if(invaders[c][r].alive) aliveInv.push(invaders[c][r]);
      }
    }
    if(aliveInv.length>0){
      let shooter=aliveInv[Math.floor(Math.random()*aliveInv.length)];
      enemyBullets.push({x:shooter.x+invaderWidth/2,y:shooter.y+invaderHeight});
    }
  }
}
function updateEnemyBullets(){
  for(let i=enemyBullets.length-1;i>=0;i--){
    let b=enemyBullets[i];
    b.y+=3;
    if(b.y>canvas.height) enemyBullets.splice(i,1);
    else if(b.x>paddleX&&b.x<paddleX+paddleWidth&&b.y>canvas.height-paddleHeight){
      gameState="gameover"; playNoise();
    }
  }
}

/* ===== Stage Clear ===== */
function checkStageClear(){
  let allBricksDead=true;
  for(let c=0;c<brickColCount;c++){
    for(let r=0;r<brickRowCount;r++){
      if(bricks[c][r].alive) allBricksDead=false;
    }
  }
  let allInvadersDead=true;
  for(let c=0;c<invaderColCount;c++){
    for(let r=0;r<invaderRowCount;r++){
      if(invaders[c][r].alive) allInvadersDead=false;
    }
  }
  if(allBricksDead||allInvadersDead){
    if(level>=maxLevel){
      gameState="ending"; stopBGM();
    }else{
      level++;
      initBricks(); initInvaders();
      balls=[{x:240,y:450,dx:2,dy:-2}];
      bricksBroken=0; enemyBullets=[];
    }
  }
}

/* ===== Intro Story ===== */
let introText=[
  "西暦 21XX年…",
  "地球の防衛ラインを守るブロックが侵略者に狙われた。",
  "あなたは最後の防衛者。",
  "すべての侵略者を撃退し、惑星を守れ！"
];
let introIndex=0, introChar=0;
function drawIntro(){
  ctx.font="18px Orbitron"; ctx.fillStyle="#0ff"; ctx.textAlign="center";
  let y=160;
  for(let i=0;i<introIndex;i++){
    ctx.fillText(introText[i],240,y+i*30);
  }
  let line=introText[introIndex].substring(0,introChar);
  ctx.fillText(line,240,y+introIndex*30);
  if(introChar<introText[introIndex].length){
    introChar++;
  } else if(introIndex<introText.length-1){
    introIndex++; introChar=0;
  } else {
    drawButton("START",180,360,120,40);
  }
}

/* ===== Game Loop ===== */
function loop(){
  t++; ctx.clearRect(0,0,480,480); drawStars(); drawPlanets(); buttons=[];
  if(gameState==="intro"){ drawIntro(); requestAnimationFrame(loop); return; }
  if(gameState==="gameover"){ ctx.font="24px Orbitron";ctx.fillStyle="#f44";ctx.textAlign="center";ctx.fillText("GAME OVER",240,180); drawButton("RESTART",180,240,120,40,"#f44"); requestAnimationFrame(loop); return; }
  if(gameState==="ending"){ ctx.font="24px Orbitron";ctx.fillStyle="#0f0";ctx.textAlign="center";ctx.fillText("YOU WIN!",240,180); drawButton("RESTART",180,240,120,40,"#0f0"); requestAnimationFrame(loop); return; }

  // playing
  drawBricks(); drawInvaders(); drawPaddle(); drawBalls(); drawEnemyBullets();
  collisionBricks(); collisionInvaders();
  moveInvaders(); invaderShoot(); updateEnemyBullets();

  for(let i=balls.length-1;i>=0;i--){
    let b=balls[i];
    if(b.x+b.dx>480-ballRadius||b.x+b.dx<ballRadius)b.dx=-b.dx;
    if(b.y+b.dy<ballRadius)b.dy=-b.dy;
    else if(b.y+b.dy>480-ballRadius){
      if(b.x>paddleX&&b.x<paddleX+paddleWidth) b.dy=-b.dy;
      else balls.splice(i,1);
    }
    b.x+=b.dx;b.y+=b.dy;
  }
  if(balls.length===0){ playNoise(); gameState="gameover"; }
  if(rightPressed&&paddleX<480-paddleWidth)paddleX+=5;
  else if(leftPressed&&paddleX>0)paddleX-=5;
  checkStageClear();
  requestAnimationFrame(loop);
}
loop();

/* ===== Input ===== */
document.addEventListener("keydown",e=>{
  if(e.key==="ArrowRight") rightPressed=true;
  if(e.key==="ArrowLeft") leftPressed=true;
});
document.addEventListener("keyup",e=>{
  if(e.key==="ArrowRight") rightPressed=false;
  if(e.key==="ArrowLeft") leftPressed=false;
});
// Touch controls for mobile
function handleTouch(e){
  const rect=canvas.getBoundingClientRect();
  const scaleX=canvas.width/rect.width;
  const scaleY=canvas.height/rect.height;
  const touch=e.touches[0];
  const touchX=(touch.clientX-rect.left)*scaleX;
  const touchY=(touch.clientY-rect.top)*scaleY;

  for(const b of buttons){
    if(touchX>=b.x&&touchX<=b.x+b.w&&touchY>=b.y&&touchY<=b.y+b.h){
      if(b.label==="START"){initAudio();startBGM();initInvaders();initBricks();gameState="playing";}
      if(b.label==="RESTART"){retryGame();initAudio();startBGM();}
      e.preventDefault();
      return;
    }
  }

  if(gameState==="playing"){
    paddleX=Math.min(Math.max(touchX-paddleWidth/2,0),canvas.width-paddleWidth);
    e.preventDefault();
  }
}
canvas.addEventListener("touchstart", handleTouch, { passive: false });
canvas.addEventListener("touchmove", handleTouch, { passive: false });
</script>
</body>
</html>
